# Nom du workflow qui s'affichera dans l'onglet Actions de GitHub
name: Docker Publish CI

# Définit les déclencheurs pour ce workflow
on:
  # Se déclenche à chaque push sur la branche "main"
  push:
    branches: [ "main" ]
  # Permet de lancer manuellement ce workflow depuis l'interface GitHub
  workflow_dispatch:

# Définit les tâches (jobs) à exécuter
jobs:
  build-and-push-multi-arch:
    # Utilise la dernière version d'Ubuntu comme environnement d'exécution
    runs-on: ubuntu-latest

    # Séquence des étapes pour ce job
    steps:
    # 1. Récupère le code du dépôt
    - name: Check out repository code
      uses: actions/checkout@v4

    # 2. Met en place QEMU pour l'émulation multi-architecture
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3

    # 3. Met en place Docker Buildx pour permettre les builds multi-architecture
    - name: Set up Docker Buildx
      id: buildx # Ajout d'un ID pour pouvoir y faire référence plus tard
      uses: docker/setup-buildx-action@v3

    # 4. Se connecte à Docker Hub en utilisant les secrets configurés
    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    # 5. Définit les métadonnées de l'image (tags, etc.)
    - name: Docker meta
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: holaflenain/caddypanel

    # 6. Construit et pousse l'image Docker (avec cache)
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        # Construit l'image pour les architectures amd64 (standard) et arm64 (Raspberry Pi, etc.)
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        # Ajout du cache pour accélérer les builds futurs
        cache-from: type=gha
        cache-to: type=gha,mode=max